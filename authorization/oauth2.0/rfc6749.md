## oauth 2.0?

산업 표준 인증(authorization) 프로토콜

웹 애플리케이션, 데스크탑 애플리케이션, 모바일 및 휴대용 장치에 대해 특정 인증 흐름을 제공함

이를 통해 client 개발자가 간단하게 인증 기능을 구현하도록 도와줌

애플리케이션이 third-party 애플리케이션에 resource 제공하기 위해 resource owner의 credentials를 공유하지 않는 대신 별도의 crendentials을 발급하여 접근할 수 있도록 하는 메커니즘을 가짐

## 역할

### resource owner

protected source에 접근할 수 있는 entity

resource owner가 사람일 경우 end-user라고 칭함

### resource server

protected source를 호스팅하는 server

access token을 사용하여 resource 접근 요청을 받고 응답함

### client

resource owner를 대신하여 권한을 가지고 protected source를 요청하는 애플리케이션

여기서 말하는 client는 특정 수단이 아닌 서버, 데스크탑, 모바일 등 protected source를 요청하는 애플리케이션 자체를 말함

### authorization server

resource owner가 인증을 마치면 client에게 access token을 발급하는 server

resource server와 authorization server는 동일한 서버이거나 별도로 관리할 수 있음

단일 authorization server가 여러 resource server에서 받는 access token을 발급할 수 있음

## Abstract protocol flow

![protocol flow](imgs/protocol-flow.png)

* A. [client -> resource owner] authorization request 전송
    * client가 resource owner에게 authroziation request 요청을 보냄
    * authorization server를 통하거나 resource owner에게 직접 요청을 보낸다
    * resource owner - authentication

* B. [authorization server -> client] authorization grant 수신
    * resource owner가 인증을 마치면 client는 authroziation server로부터 authorization grant를 받음 - resource owner의 authorization을 나타내는 credentials(자격 증명)
    * RFC 6749 명세에 따르면 authrozation grant의 유형(type)은 4가지이고, 추가적으로 확장 타입을 지원함
    * client가 authroziation request를 보내는 방법과 authorization server에서 지원하는 유형에 따라 grant 타입이 결정됨(보안 수준)

* C. [client -> authorization server] access token 요청
    * client의 authorization grant를 통해 client가 authorization server에 access token을 요청함

* D. [authorization server -> client] access token 발급
    * authroization server는 client를 인증하고 authrozation grant를 검증함
    * 유효하다면 acccess token 발급

* E. [client -> resource server] protected source 요청
    * access token을 통해 client에서 resource server에 protected source를 요청함

* F. [resource server -> client] protected source 응답
    * resource server는 access token을 검증하고, 유효하다면 요청에 응답함

## Basic authrozation grant

resource owner가 authorization server에 인증을 마치면 authroziation server가 client에게 응답해주는 resource owner의 권한을 나타내는 자격증명(credentials)임

이후에 client가 access token을 얻을 때 사용됨

grant type은 총 4가지임 (별도의 type을 정의할 수도 있음)  

보안 수준 및 client 애플리케이션 유형 등에 따라 선택하면 됨

###  Authorization code (보통 사용되는 유형) 

**flow**

```
1. client -> resource owner       : 인증 요청(+ 접근 허용 동의)
2. authorization server -> client : authroziation code 발급(resource server의 client 인증)
3. client -> authroziation server : access token 요청 with authroziation code
4. authrozation server -> client  : access token 발급
```

**특징**

access token이 백단에서 이뤄짐(client - authorization, resource server)

browser 등에 token 또는 resource owner에 대한 데이터 노출이 없음

또한 resource server에서 client에 대한 인증을 진행함

### Implicit

**flow**

```
1. client -> resource owner        : 인증 요청(+ 접근 허용 동의)
2. authorization server ->  client : access token 발급(client redirect uri 활용, client 인증 X)
3. 이후 동일
```
**특징**

authorization server에서 client에 대한 인증을 진행하지 않음

중간과정(authroziation code)없이 resource owner의 redirect uri을 통해 access token이 전달되므로, user agent에 접근할 수 있는 다른 애플리케이션에 노출될 수 있음

### Resource owner password credentials (Password grant)

**flow**

```
1. resource owner -> client       : crendentials(username, password) 전달
2. client -> authorization server : access token 요청(resource owner crendentials 전달)
3. authorization server -> client : crendentials 검증 후 access token 발급
4. 이후 동일
```

**특징**

client에게 직접적으로 end-user의 crendentials를 공유함


### Client credentials

**flow**

```
1. client -> authorization server : client credentials 전달
2. authorization server -> client : access token 발급
3. client -> resource server      : protected resource 접근
```

**특징**

resource owner와 관련없는 데이터에 접근할 때 사용되는 방식

## Additional authroization grant

### Proof key for code exchange (PCKE)

**flow**

```
1. client -> authorization server : authroization 요청 (code_challenge, code_challenge_method 전달)
2. authorization server -> client : authorization code 발급 (code_challenge, code_challenge_method 저장)
3. client -> authorization server : access token 요청 (code_verifier 전달)
4. authorization server -> client : access token 발급 (code_challenge, code_challenge_method를 통해 code_verifier 검증)
```

code_challenge : 임의 문자열 A를 sha256으로 해시한 값

code_verifier : 임의 문자열 A

**특징**

HAMC 방식을 사용하여 access token 발급 과정을 거침

공격자는 authorization code를 가로채도 code_verfier가 없으면 access token을 발급할 수 없음

다만 authorization server가 PKCE 방식을 지원해야 하며, authorization code를 사용해야 client를 보호할 수 있음

### Device Code

**flow**

```
1. client -> authroization server : code 요청 (client id 전달)
2. authorization server -> client : device code, user code, verfication url (user code 입력하는 곳) 전달
3. client -> resource owner       : 브라우저를 통해 verfication url 표시
4. resource owner                 : user code 입력 (+ 접근 권한 허용)
5. client -> authorozation server : resource owner가 user code를 통해 인증을 완료했는지 확인
6. authrozation server -> client  : device code, client id를 검증한 후 client에게 access token 전달
```

**특징**

client가 제한된 입력 장치(IoT 장치, 게임 콘솔 등)일 때 사용하는 방식

별도의 장치를 통해 인증을 진행함

## 참고

[RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749#section-1.1)

[bytebytego - oauth flow](https://blog.bytebytego.com/i/135955829/oauth-explained-with-simple-terms)

[frontegg - grant types](https://frontegg.com/blog/oauth-grant-types)
